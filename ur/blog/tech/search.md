---

brief: |
  i18n.site اب بغیر سرور کے مکمل متن کی تلاش کو سپورٹ کرتی ہے۔

  یہ مضمون خالص فرنٹ اینڈ فل ٹیکسٹ سرچ ٹکنالوجی کے نفاذ کو متعارف کرایا گیا ہے، بشمول IndexedDB کے ذریعہ بنایا گیا الٹا انڈیکس، سابقہ تلاش، الفاظ کی تقسیم کی اصلاح اور کثیر زبان کی حمایت۔

  موجودہ حلوں کے مقابلے میں، i18n.site کی خالص فرنٹ اینڈ فل ٹیکسٹ سرچ سائز میں چھوٹی اور تیز ہے، چھوٹے اور درمیانے درجے کی ویب سائٹس جیسے دستاویزات اور بلاگز کے لیے موزوں ہے، اور آف لائن دستیاب ہے۔

---

# خالص فرنٹ اینڈ الٹی مکمل متن کی تلاش

## ترتیب

کئی ہفتوں کی ترقی کے بعد [i18n.site](//i18n.site) (ایک مکمل طور پر جامد markdown کثیر لسانی ترجمہ & ویب سائٹ بنانے کا ٹول) اب خالص فرنٹ اینڈ فل ٹیکسٹ سرچ کو سپورٹ کرتا ہے۔

<p style="display:flex;flex-wrap:wrap;justify-content:center"><img src="//p.3ti.site/1727600475.avif" style="width:320px"><img src="//p.3ti.site/1727602760.avif" style="width:320px"></p>

یہ [i18n.site](//i18n.site) `i18n.site` خالص فرنٹ اینڈ فل ٹیکسٹ سرچ کے تکنیکی نفاذ کا اشتراک کرے گا۔

کوڈ اوپن : [سرچ کرنل](//github.com/i18n-site/ie/tree/main/qy) / [انٹرایکٹو انٹرفیس](//github.com/i18n-site/plugin/tree/main/qy)

## سرور لیس فل ٹیکسٹ سرچ حل کا جائزہ

چھوٹے اور درمیانے درجے کی مکمل طور پر جامد ویب سائٹس جیسے دستاویزات/ذاتی بلاگز کے لیے، خود ساختہ فل ٹیکسٹ سرچ بیک اینڈ بنانا بہت بھاری ہے، اور سروس فری فل ٹیکسٹ سرچ زیادہ عام انتخاب ہے۔

سرور لیس فل ٹیکسٹ سرچ حل دو وسیع زمروں میں آتے ہیں:

سب سے پہلے، اسی طرح [algolia.com](//algolia.com) تیسری پارٹی تلاش سروس فراہم کرنے والے مکمل متن کی تلاش کے لئے فرنٹ اینڈ اجزاء فراہم کرتے ہیں.

اس طرح کی خدمات کو تلاش کے حجم کی بنیاد پر ادائیگی کی ضرورت ہوتی ہے، اور ویب سائٹ کی تعمیل جیسے مسائل کی وجہ سے اکثر مینلینڈ چین میں صارفین کے لیے دستیاب نہیں ہوتی ہیں۔

اسے آف لائن استعمال نہیں کیا جا سکتا، انٹرانیٹ پر استعمال نہیں کیا جا سکتا، اور اس کی بڑی حدود ہیں۔ یہ مضمون زیادہ بحث نہیں کرتا۔

دوسرا خالص فرنٹ اینڈ فل ٹیکسٹ سرچ ہے۔

فی الحال [lunrjs](//lunrjs.com) عام خالص فرنٹ اینڈ فل ٹیکسٹ سرچ میں شامل ہیں اور [ElasticLunr.js](//github.com/weixsong/elasticlunr.js) ( `lunrjs` سیکنڈری ڈیولپمنٹ پر مبنی)۔

`lunrjs` انڈیکس بنانے کے دو طریقے ہیں، اور دونوں کے اپنے مسائل ہیں۔

1. پہلے سے تیار کردہ انڈیکس فائلیں۔

   چونکہ انڈیکس میں تمام دستاویزات کے الفاظ شامل ہیں، اس لیے یہ سائز میں بڑا ہے۔
   جب بھی کوئی دستاویز شامل یا ترمیم کی جاتی ہے، ایک نئی انڈیکس فائل کو لوڈ کرنا ضروری ہے۔
   یہ صارف کے انتظار کے وقت میں اضافہ کرے گا اور بہت زیادہ بینڈوتھ استعمال کرے گا۔

2. دستاویزات کو لوڈ کریں اور پرواز پر اشاریہ جات بنائیں

   انڈیکس بنانا ایک کمپیوٹیشنل بہت بڑا کام ہے جب بھی آپ انڈیکس تک رسائی حاصل کرتے ہیں تو واضح وقفے اور خراب صارف کے تجربے کا سبب بنتا ہے۔

---

`lunrjs` کے علاوہ، کچھ دوسرے مکمل متن کی تلاش کے حل بھی ہیں، جیسے :

[fusejs](//www.fusejs.io) ، تلاش کرنے کے لیے تاروں کے درمیان مماثلت کا حساب لگائیں۔

اس حل کی کارکردگی انتہائی ناقص ہے اور اسے مکمل متن کی تلاش کے لیے استعمال نہیں کیا جا سکتا (دیکھیں [Fuse.js طویل استفسار میں 10 سیکنڈ سے زیادہ وقت لگتا ہے، اسے کیسے بہتر بنایا جائے؟](//stackoverflow.com/questions/70984437/fuse-js-takes-10-seconds-with-semi-long-queries) )۔

[TinySearch](//github.com/tinysearch/tinysearch) ، تلاش کرنے کے لیے بلوم فلٹر کا استعمال کریں، سابقہ تلاش کے لیے استعمال نہیں کیا جا سکتا (مثال کے طور پر، درج کریں `goo` ، تلاش `good` ، `google` )، اور ایسا ہی خودکار تکمیل کا اثر حاصل نہیں کر سکتا۔

موجودہ حل کی کوتاہیوں کی وجہ سے، `i18n.site` نے ایک نیا خالص فرنٹ اینڈ فل ٹیکسٹ سرچ سلوشن تیار کیا، جس میں درج ذیل خصوصیات ہیں :

1. کثیر زبان کی تلاش کو سپورٹ کرتا ہے اور سائز میں چھوٹا ہے `gzip` پیکیجنگ کے بعد سرچ کرنل کا سائز `6.9KB` ہے (موازنہ کے لیے، `lunrjs` کا سائز `25KB` ہے)۔
1. `indexedb` کی بنیاد پر ایک الٹا انڈیکس بنائیں، جو کم میموری لیتا ہے اور تیز ہے۔
1. جب دستاویزات کو شامل/تبدیل کیا جاتا ہے، صرف شامل یا ترمیم شدہ دستاویزات کو دوبارہ ترتیب دیا جاتا ہے، جس سے حسابات کی مقدار کم ہوتی ہے۔
1. پریفکس تلاش کی حمایت کرتا ہے اور صارف کے ٹائپ کرنے کے دوران حقیقی وقت میں تلاش کے نتائج دکھا سکتا ہے۔
1. آف لائن دستیاب ہے۔

ذیل میں، `i18n.site` تکنیکی نفاذ کی تفصیلات کو تفصیل سے متعارف کرایا جائے گا۔

## کثیر لسانی الفاظ کی تقسیم

ورڈ سیگمنٹیشن براؤزر کا اصل لفظ سیگمنٹیشن `Intl.Segmenter` استعمال کرتا ہے، اور تمام مین اسٹریم براؤزر اس انٹرفیس کو سپورٹ کرتے ہیں۔

![](//p.3ti.site/1727667759.avif)

لفظ سیگمنٹیشن `coffeescript` کوڈ درج ذیل ہے۔

```coffee
SEG = new Intl.Segmenter 0, granularity: "word"

seg = (txt) =>
  r = []
  for {segment} from SEG.segment(txt)
    for i from segment.split('.')
      i = i.trim()
      if i and !'| `'.includes(i) and !/\p{P}/u.test(i)
        r.push i
  r

export default seg

export segqy = (q) =>
  seg q.toLocaleLowerCase()
```

میں:

* `/\p{P}/` ایک ریگولر ایکسپریشن ہے جو اوقاف { نشانات سے میل کھاتا `! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _` ۔ | } `</p><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"> `split('.')` ہے کیونکہ `Firefox` براؤزر لفظ سیگمنٹیشن سیگمنٹ `. ` نہیں کرتا ہے۔</li>


## انڈیکس بلڈنگ

5 آبجیکٹ اسٹوریج ٹیبل `IndexedDB` میں بنائے گئے تھے :

* `word` : id -
* `doc` : id - url - دستاویز کا ورژن نمبر
* دستاویز id - id کی `docWord` :
* `prefix` : - لفظ id
* `rindex` : لفظ id - دستاویز id : لائن نمبرز کی صف

دستاویز `url` اور ورژن نمبر `ver` کی صف میں جائیں، اور تلاش کریں کہ آیا دستاویز ٹیبل `doc` میں موجود ہے۔ اگر یہ موجود نہیں ہے، تو ایک الٹا انڈیکس بنائیں۔ ایک ہی وقت میں، ان دستاویزات کے لیے الٹا انڈیکس ہٹا دیں جو پاس نہیں ہوئے تھے۔

اس طرح، انکریمنٹل انڈیکسنگ حاصل کی جا سکتی ہے اور حساب کی مقدار کم ہو جاتی ہے۔

فرنٹ اینڈ انٹرایکشن میں، پہلی بار لوڈ کرتے وقت وقفہ سے بچنے کے لیے انڈیکس کا لوڈنگ پروگریس بار دکھایا جا سکتا ہے، "اینیمیشن کے ساتھ پروگریس بار، ایک سنگل پر مبنی progress + خالص css نفاذ" [انگریزی](//dev.to/i18n-site/a-single-progress-uses-pure-css-to-achieve-animation-effects-2oo) / [چینی](//juejin.cn/post/7413586285954154522) ۔

### IndexedDB اعلی سمورتی تحریر

[idb](//www.npmjs.com/package/idb) پروجیکٹ IndexedDB

IndexedDB پڑھنا اور لکھنا غیر مطابقت پذیر ہیں۔ انڈیکس بناتے وقت، انڈیکس بنانے کے لیے دستاویزات کو بیک وقت لوڈ کیا جائے گا۔

مسابقتی تحریر کی وجہ سے ڈیٹا کے جزوی نقصان سے بچنے کے لیے، آپ نیچے دیئے گئے `coffeescript` کوڈ کا حوالہ دے سکتے ہیں اور مسابقتی تحریروں کو روکنے کے لیے پڑھنے اور لکھنے کے درمیان `ing` کیش شامل کر سکتے ہیں۔

```coffee
pusher = =>
  ing = new Map()
  (table, id, val)=>
    id_set = ing.get(id)
    if id_set
      id_set.add val
      return

    id_set = new Set([val])
    ing.set id, id_set
    pre = await table.get(id)
    li = pre?.li or []

    loop
      to_add = [...id_set]
      li.push(...to_add)
      await table.put({id,li})
      for i from to_add
        id_set.delete i
      if not id_set.size
        ing.delete id
        break
    return

rindexPush = pusher()
prefixPush = pusher()
```

## صحت سے متعلق اور یاد کرنا

تلاش پہلے صارف کے درج کردہ مطلوبہ الفاظ کو الگ کرے گی۔

فرض کریں کہ ورڈ سیگمنٹیشن کے بعد `N` الفاظ ہیں جب نتائج واپس آتے ہیں تو پہلے تمام مطلوبہ الفاظ پر مشتمل نتائج واپس کیے جائیں گے، اور پھر `N-1` ، `N-2` ،...، `1` کلیدی الفاظ پر مشتمل نتائج واپس کیے جائیں گے۔

پہلے دکھائے گئے تلاش کے نتائج استفسار کی درستگی کو یقینی بناتے ہیں، اور بعد میں لوڈ کیے گئے نتائج (لوڈ مزید بٹن پر کلک کریں) یاد کرنے کی شرح کو یقینی بناتے ہیں۔

![](//p.3ti.site/1727684564.avif)

## مانگ پر لوڈ کریں۔

رسپانس کی رفتار کو بہتر بنانے کے لیے، سرچ آن ڈیمانڈ لوڈنگ کو لاگو کرنے کے لیے `yield` جنریٹر کا استعمال کرتی ہے، اور `limit` بھی کوئی نتیجہ پوچھتا ہے تو واپس آتا ہے۔

نوٹ کریں کہ جب بھی آپ `yield` کے بعد دوبارہ تلاش کرتے ہیں، آپ کو `IndexedDB` کا استفسار ٹرانزیکشن دوبارہ کھولنے کی ضرورت ہوتی ہے۔

## اصل وقت کی تلاش کا سابقہ

صارف کے ٹائپ کرنے کے دوران تلاش کے نتائج ظاہر کرنے کے لیے، مثال کے طور پر، جب `wor` درج کیا جاتا ہے، تو `wor` کے ساتھ سابقہ والے الفاظ جیسے `words` اور `work` دکھائے جاتے ہیں۔

![](//p.3ti.site/1727684944.avif)

سرچ کرنل الفاظ کی تقسیم کے بعد آخری لفظ کے لیے `prefix` ٹیبل کا استعمال کرے گا تاکہ اس کے ساتھ سابقہ تمام الفاظ تلاش کیے جا سکیں، اور ترتیب میں تلاش کریں۔

اینٹی شیک فنکشن `debounce` فرنٹ اینڈ انٹرایکشن میں بھی استعمال ہوتا ہے (ذیل میں لاگو کیا جاتا ہے) تاکہ صارف کے ان پٹ کو متحرک کرنے والی تلاشوں کی فریکوئنسی کو کم کیا جا سکے اور حساب کتاب کی مقدار کو کم کیا جا سکے۔

```js
export default (wait, func) => {
  var timeout;
  return function(...args) {
    clearTimeout(timeout);
    timeout = setTimeout(func.bind(this, ...args), wait);
  };
}
```

## آف لائن دستیاب ہے۔

انڈیکس ٹیبل اصل متن کو ذخیرہ نہیں کرتا، صرف الفاظ، جو ذخیرہ کرنے کی مقدار کو کم کرتا ہے۔

تلاش کے نتائج کو نمایاں کرنے کے لیے اصل متن کو دوبارہ لوڈ کرنے کی ضرورت ہوتی ہے، اور `service worker` سے مماثلت بار بار نیٹ ورک کی درخواستوں سے بچ سکتی ہے۔

ایک ہی وقت میں، کیونکہ `service worker` تمام مضامین کو کیش کرتا ہے، ایک بار جب صارف تلاش کرتا ہے، تلاش سمیت پوری ویب سائٹ آف لائن دستیاب ہوتی ہے۔

## مارک ڈاون دستاویزات کی اصلاح دکھائیں۔

`i18n.site` کا خالص فرنٹ اینڈ سرچ حل `MarkDown` دستاویزات کے لیے موزوں ہے۔

تلاش کے نتائج دکھاتے وقت، باب کا نام ظاہر ہو جائے گا اور کلک کرنے پر باب نیویگیٹ ہو جائے گا۔

![](//p.3ti.site/1727686552.avif)

## خلاصہ کریں۔

الٹی مکمل متن کی تلاش مکمل طور پر سامنے والے سرے پر لاگو ہوتی ہے، کسی سرور کی ضرورت نہیں ہے۔ یہ چھوٹی اور درمیانے درجے کی ویب سائٹس جیسے دستاویزات اور ذاتی بلاگز کے لیے بہت موزوں ہے۔

`i18n.site` اوپن سورس سیلف ڈیولپڈ خالص فرنٹ اینڈ سرچ، سائز میں چھوٹی اور تیز رسپانس، موجودہ خالص فرنٹ اینڈ فل ٹیکسٹ سرچ کی خامیوں کو دور کرتی ہے اور صارف کا بہتر تجربہ فراہم کرتی ہے۔