---

brief: |
  i18n.site ಈಗ ಸರ್ವರ್ಲೆಸ್ ಪೂರ್ಣ-ಪಠ್ಯ ಹುಡುಕಾಟವನ್ನು ಬೆಂಬಲಿಸುತ್ತದೆ.

  IndexedDB ನಿರ್ಮಿಸಿದ ತಲೆಕೆಳಗಾದ ಸೂಚ್ಯಂಕ, ಪೂರ್ವಪ್ರತ್ಯಯ ಹುಡುಕಾಟ, ಪದ ವಿಭಜನೆ ಆಪ್ಟಿಮೈಸೇಶನ್ ಮತ್ತು ಬಹು-ಭಾಷಾ ಬೆಂಬಲ ಸೇರಿದಂತೆ ಶುದ್ಧ ಮುಂಭಾಗದ ಪೂರ್ಣ-ಪಠ್ಯ ಹುಡುಕಾಟ ತಂತ್ರಜ್ಞಾನದ ಅನುಷ್ಠಾನವನ್ನು ಈ ಲೇಖನವು ಪರಿಚಯಿಸುತ್ತದೆ.

  ಅಸ್ತಿತ್ವದಲ್ಲಿರುವ ಪರಿಹಾರಗಳೊಂದಿಗೆ ಹೋಲಿಸಿದರೆ, i18n.site ನ ಶುದ್ಧ ಮುಂಭಾಗದ ಪೂರ್ಣ-ಪಠ್ಯ ಹುಡುಕಾಟವು ಗಾತ್ರದಲ್ಲಿ ಚಿಕ್ಕದಾಗಿದೆ ಮತ್ತು ವೇಗವಾಗಿದೆ, ಡಾಕ್ಯುಮೆಂಟ್ಗಳು ಮತ್ತು ಬ್ಲಾಗ್ಗಳಂತಹ ಸಣ್ಣ ಮತ್ತು ಮಧ್ಯಮ ಗಾತ್ರದ ವೆಬ್ಸೈಟ್ಗಳಿಗೆ ಸೂಕ್ತವಾಗಿದೆ ಮತ್ತು ಆಫ್ಲೈನ್ನಲ್ಲಿ ಲಭ್ಯವಿದೆ.

---

# ಶುದ್ಧ ಮುಂಭಾಗದ ಕೊನೆಯಲ್ಲಿ ತಲೆಕೆಳಗಾದ ಪೂರ್ಣ-ಪಠ್ಯ ಹುಡುಕಾಟ

## ಅನುಕ್ರಮ

ಹಲವಾರು ವಾರಗಳ ಅಭಿವೃದ್ಧಿಯ ನಂತರ, [i18n.site](//i18n.site) (ಸಂಪೂರ್ಣವಾಗಿ ಸ್ಥಿರ markdown ಬಹುಭಾಷಾ ಅನುವಾದ & ವೆಬ್ಸೈಟ್ ನಿರ್ಮಾಣ ಸಾಧನ) ಈಗ ಶುದ್ಧ ಮುಂಭಾಗದ ಪೂರ್ಣ-ಪಠ್ಯ ಹುಡುಕಾಟವನ್ನು ಬೆಂಬಲಿಸುತ್ತದೆ.

<p style="display:flex;flex-wrap:wrap;justify-content:center"><img src="//p.3ti.site/1727600475.avif" style="width:320px"><img src="//p.3ti.site/1727602760.avif" style="width:320px"></p>

ಈ ಲೇಖನವು `i18n.site` ಶುದ್ಧ ಮುಂಭಾಗದ ಪೂರ್ಣ-ಪಠ್ಯ ಹುಡುಕಾಟದ ತಾಂತ್ರಿಕ ಅನುಷ್ಠಾನವನ್ನು ಹಂಚಿಕೊಳ್ಳುತ್ತದೆ ಹುಡುಕಾಟ ಪರಿಣಾಮವನ್ನು ಅನುಭವಿಸಲು [i18n.site](//i18n.site)

[ಕೋಡ್](//github.com/i18n-site/ie/tree/main/qy) [ಓಪನ್](//github.com/i18n-site/plugin/tree/main/qy) / :

## ಸರ್ವರ್ಲೆಸ್ ಪೂರ್ಣ-ಪಠ್ಯ ಹುಡುಕಾಟ ಪರಿಹಾರಗಳ ವಿಮರ್ಶೆ

ಡಾಕ್ಯುಮೆಂಟ್ಗಳು/ವೈಯಕ್ತಿಕ ಬ್ಲಾಗ್ಗಳಂತಹ ಸಣ್ಣ ಮತ್ತು ಮಧ್ಯಮ ಗಾತ್ರದ ಸಂಪೂರ್ಣವಾಗಿ ಸ್ಥಿರವಾದ ವೆಬ್ಸೈಟ್ಗಳಿಗಾಗಿ, ಸ್ವಯಂ-ನಿರ್ಮಿತ ಪೂರ್ಣ-ಪಠ್ಯ ಹುಡುಕಾಟ ಬ್ಯಾಕೆಂಡ್ ಅನ್ನು ನಿರ್ಮಿಸುವುದು ತುಂಬಾ ಭಾರವಾಗಿರುತ್ತದೆ ಮತ್ತು ಸೇವೆ-ಮುಕ್ತ ಪೂರ್ಣ-ಪಠ್ಯ ಹುಡುಕಾಟವು ಹೆಚ್ಚು ಸಾಮಾನ್ಯ ಆಯ್ಕೆಯಾಗಿದೆ.

ಸರ್ವರ್ಲೆಸ್ ಪೂರ್ಣ-ಪಠ್ಯ ಹುಡುಕಾಟ ಪರಿಹಾರಗಳು ಎರಡು ವಿಶಾಲ ವರ್ಗಗಳಾಗಿ ಬರುತ್ತವೆ:

ಮೊದಲನೆಯದು, [algolia.com](//algolia.com) ರೀತಿಯ ಥರ್ಡ್-ಪಾರ್ಟಿ ಹುಡುಕಾಟ ಸೇವಾ ಪೂರೈಕೆದಾರರು ಪೂರ್ಣ-ಪಠ್ಯ ಹುಡುಕಾಟಕ್ಕಾಗಿ ಮುಂಭಾಗದ ಭಾಗಗಳನ್ನು ಒದಗಿಸುತ್ತಾರೆ.

ಅಂತಹ ಸೇವೆಗಳಿಗೆ ಹುಡುಕಾಟದ ಪರಿಮಾಣದ ಆಧಾರದ ಮೇಲೆ ಪಾವತಿ ಅಗತ್ಯವಿರುತ್ತದೆ ಮತ್ತು ವೆಬ್ಸೈಟ್ ಅನುಸರಣೆಯಂತಹ ಸಮಸ್ಯೆಗಳಿಂದಾಗಿ ಚೀನಾದ ಮುಖ್ಯ ಭೂಭಾಗದಲ್ಲಿರುವ ಬಳಕೆದಾರರಿಗೆ ಸಾಮಾನ್ಯವಾಗಿ ಲಭ್ಯವಿರುವುದಿಲ್ಲ.

ಇದನ್ನು ಆಫ್ಲೈನ್ನಲ್ಲಿ ಬಳಸಲಾಗುವುದಿಲ್ಲ, ಇಂಟ್ರಾನೆಟ್ನಲ್ಲಿ ಬಳಸಲಾಗುವುದಿಲ್ಲ ಮತ್ತು ಹೆಚ್ಚಿನ ಮಿತಿಗಳನ್ನು ಹೊಂದಿದೆ. ಈ ಲೇಖನವು ಹೆಚ್ಚು ಚರ್ಚಿಸುವುದಿಲ್ಲ.

ಎರಡನೆಯದು ಶುದ್ಧ ಮುಂಭಾಗದ ಪೂರ್ಣ-ಪಠ್ಯ ಹುಡುಕಾಟವಾಗಿದೆ.

ಪ್ರಸ್ತುತ, ಸಾಮಾನ್ಯ ಶುದ್ಧ ಮುಂಭಾಗದ ಪೂರ್ಣ-ಪಠ್ಯ ಹುಡುಕಾಟಗಳು [lunrjs](//lunrjs.com) ಮತ್ತು [ElasticLunr.js](//github.com/weixsong/elasticlunr.js) ( `lunrjs` ದ್ವಿತೀಯ ಅಭಿವೃದ್ಧಿಯನ್ನು ಆಧರಿಸಿ) ಒಳಗೊಂಡಿವೆ.

`lunrjs` ಸೂಚ್ಯಂಕಗಳನ್ನು ನಿರ್ಮಿಸಲು ಎರಡು ಮಾರ್ಗಗಳಿವೆ, ಮತ್ತು ಎರಡೂ ತಮ್ಮದೇ ಆದ ಸಮಸ್ಯೆಗಳನ್ನು ಹೊಂದಿವೆ.

1. ಪೂರ್ವ-ನಿರ್ಮಿತ ಸೂಚ್ಯಂಕ ಫೈಲ್ಗಳು

   ಸೂಚ್ಯಂಕವು ಎಲ್ಲಾ ದಾಖಲೆಗಳಿಂದ ಪದಗಳನ್ನು ಒಳಗೊಂಡಿರುವ ಕಾರಣ, ಇದು ಗಾತ್ರದಲ್ಲಿ ದೊಡ್ಡದಾಗಿದೆ.
   ಡಾಕ್ಯುಮೆಂಟ್ ಅನ್ನು ಸೇರಿಸಿದಾಗ ಅಥವಾ ಮಾರ್ಪಡಿಸಿದಾಗ, ಹೊಸ ಇಂಡೆಕ್ಸ್ ಫೈಲ್ ಅನ್ನು ಲೋಡ್ ಮಾಡಬೇಕು.
   ಇದು ಬಳಕೆದಾರರ ಕಾಯುವ ಸಮಯವನ್ನು ಹೆಚ್ಚಿಸುತ್ತದೆ ಮತ್ತು ಸಾಕಷ್ಟು ಬ್ಯಾಂಡ್ವಿಡ್ತ್ ಅನ್ನು ಬಳಸುತ್ತದೆ.

2. ದಾಖಲೆಗಳನ್ನು ಲೋಡ್ ಮಾಡಿ ಮತ್ತು ಹಾರಾಡುತ್ತ ಇಂಡೆಕ್ಸ್ಗಳನ್ನು ನಿರ್ಮಿಸಿ

   ಸೂಚ್ಯಂಕವನ್ನು ನಿರ್ಮಿಸುವುದು ಕಂಪ್ಯೂಟೇಶನಲ್ ಆಗಿ ತೀವ್ರವಾದ ಕಾರ್ಯವಾಗಿದೆ, ಪ್ರತಿ ಬಾರಿ ನೀವು ಅದನ್ನು ಪ್ರವೇಶಿಸಿದಾಗ ಸೂಚ್ಯಂಕವನ್ನು ಮರುನಿರ್ಮಾಣ ಮಾಡುವುದು ಸ್ಪಷ್ಟವಾದ ವಿಳಂಬಗಳು ಮತ್ತು ಕಳಪೆ ಬಳಕೆದಾರ ಅನುಭವವನ್ನು ಉಂಟುಮಾಡುತ್ತದೆ.

---

`lunrjs` ಜೊತೆಗೆ, ಇನ್ನೂ ಕೆಲವು ಪೂರ್ಣ-ಪಠ್ಯ ಹುಡುಕಾಟ ಪರಿಹಾರಗಳಿವೆ, ಉದಾಹರಣೆಗೆ :

[fusejs](//www.fusejs.io) , ಹುಡುಕಲು ತಂತಿಗಳ ನಡುವಿನ ಹೋಲಿಕೆಯನ್ನು ಲೆಕ್ಕಹಾಕಿ.

ಈ ಪರಿಹಾರದ ಕಾರ್ಯಕ್ಷಮತೆ ಅತ್ಯಂತ ಕಳಪೆಯಾಗಿದೆ ಮತ್ತು ಪೂರ್ಣ-ಪಠ್ಯ ಹುಡುಕಾಟಕ್ಕಾಗಿ ಬಳಸಲಾಗುವುದಿಲ್ಲ (ನೋಡಿ [Fuse.js ದೀರ್ಘ ಪ್ರಶ್ನೆಗೆ 10 ಸೆಕೆಂಡುಗಳಿಗಿಂತ ಹೆಚ್ಚು ಸಮಯ ತೆಗೆದುಕೊಳ್ಳುತ್ತದೆ, ಅದನ್ನು ಹೇಗೆ ಆಪ್ಟಿಮೈಜ್ ಮಾಡುವುದು?](//stackoverflow.com/questions/70984437/fuse-js-takes-10-seconds-with-semi-long-queries) ).

[TinySearch](//github.com/tinysearch/tinysearch) , ಹುಡುಕಲು ಬ್ಲೂಮ್ ಫಿಲ್ಟರ್ ಅನ್ನು ಬಳಸಿ, ಪೂರ್ವಪ್ರತ್ಯಯ ಹುಡುಕಾಟಕ್ಕಾಗಿ ಬಳಸಲಾಗುವುದಿಲ್ಲ (ಉದಾಹರಣೆಗೆ, ನಮೂದಿಸಿ `goo` , ಹುಡುಕಾಟ `good` , `google` ), ಮತ್ತು ಇದೇ ರೀತಿಯ ಸ್ವಯಂಚಾಲಿತ ಪೂರ್ಣಗೊಳಿಸುವಿಕೆಯ ಪರಿಣಾಮವನ್ನು ಸಾಧಿಸಲಾಗುವುದಿಲ್ಲ.

ಅಸ್ತಿತ್ವದಲ್ಲಿರುವ ಪರಿಹಾರಗಳ ನ್ಯೂನತೆಗಳ ಕಾರಣದಿಂದಾಗಿ, `i18n.site` ಹೊಸ ಶುದ್ಧ ಮುಂಭಾಗದ ಪೂರ್ಣ-ಪಠ್ಯ ಹುಡುಕಾಟ ಪರಿಹಾರವನ್ನು ಅಭಿವೃದ್ಧಿಪಡಿಸಿದೆ, ಇದು ಕೆಳಗಿನ ಗುಣಲಕ್ಷಣಗಳನ್ನು ಹೊಂದಿದೆ :

1. ಬಹು-ಭಾಷಾ ಹುಡುಕಾಟವನ್ನು ಬೆಂಬಲಿಸುತ್ತದೆ ಮತ್ತು ಪ್ಯಾಕೇಜಿಂಗ್ `gzip` ನಂತರದ ಹುಡುಕಾಟ ಕರ್ನಲ್ನ ಗಾತ್ರವು `6.9KB` ಆಗಿದೆ (ಹೋಲಿಕೆಗಾಗಿ, `lunrjs` ನ ಗಾತ್ರವು `25KB` ಆಗಿದೆ)
1. `indexedb` ಆಧರಿಸಿ ತಲೆಕೆಳಗಾದ ಸೂಚಿಯನ್ನು ನಿರ್ಮಿಸಿ, ಇದು ಕಡಿಮೆ ಮೆಮೊರಿಯನ್ನು ತೆಗೆದುಕೊಳ್ಳುತ್ತದೆ ಮತ್ತು ವೇಗವಾಗಿರುತ್ತದೆ.
1. ಡಾಕ್ಯುಮೆಂಟ್ಗಳನ್ನು ಸೇರಿಸಿದಾಗ/ಮಾರ್ಪಡಿಸಿದಾಗ, ಸೇರಿಸಿದ ಅಥವಾ ಮಾರ್ಪಡಿಸಿದ ದಾಖಲೆಗಳನ್ನು ಮಾತ್ರ ಮರು-ಸೂಚಿಸಲಾಗುತ್ತದೆ, ಇದು ಲೆಕ್ಕಾಚಾರಗಳ ಪ್ರಮಾಣವನ್ನು ಕಡಿಮೆ ಮಾಡುತ್ತದೆ.
1. ಪೂರ್ವಪ್ರತ್ಯಯ ಹುಡುಕಾಟವನ್ನು ಬೆಂಬಲಿಸುತ್ತದೆ ಮತ್ತು ಬಳಕೆದಾರರು ಟೈಪ್ ಮಾಡುತ್ತಿರುವಾಗ ನೈಜ ಸಮಯದಲ್ಲಿ ಹುಡುಕಾಟ ಫಲಿತಾಂಶಗಳನ್ನು ಪ್ರದರ್ಶಿಸಬಹುದು.
1. ಆಫ್ಲೈನ್ನಲ್ಲಿ ಲಭ್ಯವಿದೆ

ಕೆಳಗೆ, `i18n.site` ತಾಂತ್ರಿಕ ಅನುಷ್ಠಾನದ ವಿವರಗಳನ್ನು ವಿವರವಾಗಿ ಪರಿಚಯಿಸಲಾಗುವುದು.

## ಬಹುಭಾಷಾ ಪದ ವಿಭಜನೆ

ವರ್ಡ್ ಸೆಗ್ಮೆಂಟೇಶನ್ ಬ್ರೌಸರ್ನ ಸ್ಥಳೀಯ ವರ್ಡ್ ಸೆಗ್ಮೆಂಟೇಶನ್ `Intl.Segmenter` ಅನ್ನು ಬಳಸುತ್ತದೆ ಮತ್ತು ಎಲ್ಲಾ ಮುಖ್ಯವಾಹಿನಿಯ ಬ್ರೌಸರ್ಗಳು ಈ ಇಂಟರ್ಫೇಸ್ ಅನ್ನು ಬೆಂಬಲಿಸುತ್ತವೆ.

![](//p.3ti.site/1727667759.avif)

ಪದ ವಿಭಜನೆ `coffeescript` ಕೋಡ್ ಈ ಕೆಳಗಿನಂತಿದೆ

```coffee
SEG = new Intl.Segmenter 0, granularity: "word"

seg = (txt) =>
  r = []
  for {segment} from SEG.segment(txt)
    for i from segment.split('.')
      i = i.trim()
      if i and !'| `'.includes(i) and !/\p{P}/u.test(i)
        r.push i
  r

export default seg

export segqy = (q) =>
  seg q.toLocaleLowerCase()
```

ಇದರಲ್ಲಿ:

* `/\p{P}/` ಎಂಬುದು ವಿರಾಮ ಚಿಹ್ನೆಗಳಿಗೆ ಹೊಂದಿಕೆಯಾಗುವ ನಿಯಮಿತ ಅಭಿವ್ಯಕ್ತಿಯಾಗಿದೆ: `! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _` { | } . `.</p><ul><li> `split('.')` ಏಕೆಂದರೆ `Firefox` ಬ್ರೌಸರ್ ವರ್ಡ್ ಸೆಗ್ಮೆಂಟೇಶನ್ ವಿಭಾಗ `. ` ಅಲ್ಲ.</li>


## ಸೂಚ್ಯಂಕ ಕಟ್ಟಡ

5 ವಸ್ತು ಸಂಗ್ರಹಣೆ ಕೋಷ್ಟಕಗಳನ್ನು `IndexedDB` ನಲ್ಲಿ ರಚಿಸಲಾಗಿದೆ :

* `word` : id -
* `doc` : id - ಡಾಕ್ಯುಮೆಂಟ್ url - ಡಾಕ್ಯುಮೆಂಟ್ ಆವೃತ್ತಿ ಸಂಖ್ಯೆ
* `docWord` : ಡಾಕ್ಯುಮೆಂಟ್ id - ವರ್ಡ್ id
* `prefix` : ಪೂರ್ವಪ್ರತ್ಯಯ - ಪದ id
* `rindex` : ವರ್ಡ್ id - ಡಾಕ್ಯುಮೆಂಟ್ id : ಸಾಲು ಸಂಖ್ಯೆಗಳ ಅರೇ

ಡಾಕ್ಯುಮೆಂಟ್ `url` ಮತ್ತು ಆವೃತ್ತಿ ಸಂಖ್ಯೆ `ver` ರ ಶ್ರೇಣಿಯಲ್ಲಿ ಪಾಸ್ ಮಾಡಿ ಮತ್ತು ಟೇಬಲ್ `doc` ರಲ್ಲಿ ಡಾಕ್ಯುಮೆಂಟ್ ಅಸ್ತಿತ್ವದಲ್ಲಿದೆಯೇ ಎಂದು ಹುಡುಕಿ. ಅದು ಅಸ್ತಿತ್ವದಲ್ಲಿಲ್ಲದಿದ್ದರೆ, ತಲೆಕೆಳಗಾದ ಸೂಚಿಯನ್ನು ರಚಿಸಿ. ಅದೇ ಸಮಯದಲ್ಲಿ, ರವಾನಿಸದ ದಾಖಲೆಗಳಿಗಾಗಿ ತಲೆಕೆಳಗಾದ ಸೂಚಿಯನ್ನು ತೆಗೆದುಹಾಕಿ.

ಈ ರೀತಿಯಾಗಿ, ಹೆಚ್ಚುತ್ತಿರುವ ಇಂಡೆಕ್ಸಿಂಗ್ ಅನ್ನು ಸಾಧಿಸಬಹುದು ಮತ್ತು ಲೆಕ್ಕಾಚಾರದ ಪ್ರಮಾಣವನ್ನು ಕಡಿಮೆಗೊಳಿಸಲಾಗುತ್ತದೆ.

ಫ್ರಂಟ್-ಎಂಡ್ ಸಂವಾದದಲ್ಲಿ, ಮೊದಲ ಬಾರಿಗೆ ಲೋಡ್ ಮಾಡುವಾಗ ವಿಳಂಬವಾಗುವುದನ್ನು ತಪ್ಪಿಸಲು ಇಂಡೆಕ್ಸ್ನ ಲೋಡಿಂಗ್ ಪ್ರೋಗ್ರೆಸ್ ಬಾರ್ ಅನ್ನು ಪ್ರದರ್ಶಿಸಬಹುದು "ಏಕವನ್ನು ಆಧರಿಸಿದ ಆನಿಮೇಷನ್ progress + ಶುದ್ಧ css ಅನುಷ್ಠಾನ" [ಇಂಗ್ಲೀಷ್](//dev.to/i18n-site/a-single-progress-uses-pure-css-to-achieve-animation-effects-2oo) / [ಚೈನೀಸ್](//juejin.cn/post/7413586285954154522) .

### IndexedDB ಹೆಚ್ಚಿನ ಏಕಕಾಲಿಕ ಬರವಣಿಗೆ

ನ ಅಸಮಕಾಲಿಕ ಎನ್ಕ್ಯಾಪ್ಸುಲೇಶನ್ ಅನ್ನು ಆಧರಿಸಿ ಯೋಜನೆಯನ್ನು [idb](//www.npmjs.com/package/idb) IndexedDB

IndexedDB ಓದುವುದು ಮತ್ತು ಬರೆಯುವುದು ಅಸಮಕಾಲಿಕವಾಗಿದೆ. ಸೂಚ್ಯಂಕವನ್ನು ರಚಿಸುವಾಗ, ಸೂಚ್ಯಂಕವನ್ನು ರಚಿಸಲು ದಾಖಲೆಗಳನ್ನು ಏಕಕಾಲದಲ್ಲಿ ಲೋಡ್ ಮಾಡಲಾಗುತ್ತದೆ.

ಸ್ಪರ್ಧಾತ್ಮಕ ಬರವಣಿಗೆಯಿಂದ ಉಂಟಾಗುವ ಭಾಗಶಃ ಡೇಟಾ ನಷ್ಟವನ್ನು ತಪ್ಪಿಸಲು, ನೀವು ಕೆಳಗಿನ `coffeescript` ಕೋಡ್ ಅನ್ನು ಉಲ್ಲೇಖಿಸಬಹುದು ಮತ್ತು ಸ್ಪರ್ಧಾತ್ಮಕ ಬರಹಗಳನ್ನು ಪ್ರತಿಬಂಧಿಸಲು ಓದುವ ಮತ್ತು ಬರೆಯುವ ನಡುವೆ `ing` ಸಂಗ್ರಹವನ್ನು ಸೇರಿಸಬಹುದು.

```coffee
pusher = =>
  ing = new Map()
  (table, id, val)=>
    id_set = ing.get(id)
    if id_set
      id_set.add val
      return

    id_set = new Set([val])
    ing.set id, id_set
    pre = await table.get(id)
    li = pre?.li or []

    loop
      to_add = [...id_set]
      li.push(...to_add)
      await table.put({id,li})
      for i from to_add
        id_set.delete i
      if not id_set.size
        ing.delete id
        break
    return

rindexPush = pusher()
prefixPush = pusher()
```

## ನಿಖರತೆ ಮತ್ತು ಮರುಸ್ಥಾಪನೆ

ಹುಡುಕಾಟವು ಮೊದಲು ಬಳಕೆದಾರರು ನಮೂದಿಸಿದ ಕೀವರ್ಡ್ಗಳನ್ನು ವಿಭಾಗಿಸುತ್ತದೆ.

ಫಲಿತಾಂಶಗಳನ್ನು ಹಿಂತಿರುಗಿಸುವಾಗ ಪದಗಳ ವಿಭಜನೆಯ ನಂತರ `N` ಪದಗಳಿವೆ ಎಂದು ಊಹಿಸಿ, ಎಲ್ಲಾ ಕೀವರ್ಡ್ಗಳನ್ನು ಹೊಂದಿರುವ ಫಲಿತಾಂಶಗಳನ್ನು ಮೊದಲು ಹಿಂತಿರುಗಿಸಲಾಗುತ್ತದೆ ಮತ್ತು ನಂತರ `N-1` , `N-2` ,..., `1` ಕೀವರ್ಡ್ಗಳನ್ನು ಹೊಂದಿರುವ ಫಲಿತಾಂಶಗಳನ್ನು ಹಿಂತಿರುಗಿಸಲಾಗುತ್ತದೆ.

ಮೊದಲು ಪ್ರದರ್ಶಿಸಲಾದ ಹುಡುಕಾಟ ಫಲಿತಾಂಶಗಳು ಪ್ರಶ್ನೆಯ ನಿಖರತೆಯನ್ನು ಖಚಿತಪಡಿಸುತ್ತದೆ ಮತ್ತು ನಂತರ ಲೋಡ್ ಮಾಡಲಾದ ಫಲಿತಾಂಶಗಳು (ಲೋಡ್ ಹೆಚ್ಚು ಬಟನ್ ಕ್ಲಿಕ್ ಮಾಡಿ) ಮರುಪಡೆಯುವಿಕೆ ದರವನ್ನು ಖಚಿತಪಡಿಸುತ್ತದೆ.

![](//p.3ti.site/1727684564.avif)

## ಬೇಡಿಕೆಯ ಮೇಲೆ ಲೋಡ್ ಮಾಡಿ

ಪ್ರತಿಕ್ರಿಯೆ ವೇಗವನ್ನು ಸುಧಾರಿಸುವ ಸಲುವಾಗಿ, ಬೇಡಿಕೆಯ ಮೇಲೆ ಲೋಡ್ ಮಾಡುವಿಕೆಯನ್ನು ಕಾರ್ಯಗತಗೊಳಿಸಲು ಹುಡುಕಾಟವು `yield` ಜನರೇಟರ್ ಅನ್ನು ಬಳಸುತ್ತದೆ ಮತ್ತು `limit` ಬಾರಿ ಫಲಿತಾಂಶವನ್ನು ಪ್ರಶ್ನಿಸಿದಾಗ ಹಿಂತಿರುಗಿಸುತ್ತದೆ.

ಪ್ರತಿ ಬಾರಿ ನೀವು `yield` ನಂತರ ಮತ್ತೆ ಹುಡುಕಿದಾಗ, ನೀವು `IndexedDB` ರ ಪ್ರಶ್ನೆ ವಹಿವಾಟನ್ನು ಪುನಃ ತೆರೆಯಬೇಕಾಗುತ್ತದೆ ಎಂಬುದನ್ನು ಗಮನಿಸಿ.

## ಪೂರ್ವಪ್ರತ್ಯಯ ನೈಜ-ಸಮಯದ ಹುಡುಕಾಟ

ಬಳಕೆದಾರರು ಟೈಪ್ ಮಾಡುವಾಗ ಹುಡುಕಾಟ ಫಲಿತಾಂಶಗಳನ್ನು ಪ್ರದರ್ಶಿಸಲು, ಉದಾಹರಣೆಗೆ, `wor` ನಮೂದಿಸಿದಾಗ, `words` ಮತ್ತು `work` ನಂತಹ `wor` ನೊಂದಿಗೆ ಪೂರ್ವಪ್ರತ್ಯಯವಿರುವ ಪದಗಳನ್ನು ಪ್ರದರ್ಶಿಸಲಾಗುತ್ತದೆ.

![](//p.3ti.site/1727684944.avif)

ಹುಡುಕಾಟ ಕರ್ನಲ್ `prefix` ಟೇಬಲ್ ಅನ್ನು ಪದ ವಿಭಜನೆಯ ನಂತರ ಅದರೊಂದಿಗೆ ಪೂರ್ವಪ್ರತ್ಯಯವಾಗಿರುವ ಎಲ್ಲಾ ಪದಗಳನ್ನು ಹುಡುಕಲು ಮತ್ತು ಅನುಕ್ರಮದಲ್ಲಿ ಹುಡುಕಲು ಕೊನೆಯ ಪದವನ್ನು ಬಳಸುತ್ತದೆ.

ಬಳಕೆದಾರರ ಇನ್ಪುಟ್ ಟ್ರಿಗರಿಂಗ್ ಹುಡುಕಾಟಗಳ ಆವರ್ತನವನ್ನು ಕಡಿಮೆ ಮಾಡಲು ಮತ್ತು ಲೆಕ್ಕಾಚಾರದ ಪ್ರಮಾಣವನ್ನು ಕಡಿಮೆ ಮಾಡಲು ಆಂಟಿ-ಶೇಕ್ ಫಂಕ್ಷನ್ `debounce` ಅನ್ನು ಫ್ರಂಟ್-ಎಂಡ್ ಸಂವಹನದಲ್ಲಿ (ಕೆಳಗಿನಂತೆ ಅಳವಡಿಸಲಾಗಿದೆ) ಬಳಸಲಾಗುತ್ತದೆ.

```js
export default (wait, func) => {
  var timeout;
  return function(...args) {
    clearTimeout(timeout);
    timeout = setTimeout(func.bind(this, ...args), wait);
  };
}
```

## ಆಫ್ಲೈನ್ನಲ್ಲಿ ಲಭ್ಯವಿದೆ

ಸೂಚ್ಯಂಕ ಕೋಷ್ಟಕವು ಮೂಲ ಪಠ್ಯವನ್ನು ಸಂಗ್ರಹಿಸುವುದಿಲ್ಲ, ಕೇವಲ ಪದಗಳು, ಇದು ಸಂಗ್ರಹಣೆಯ ಪ್ರಮಾಣವನ್ನು ಕಡಿಮೆ ಮಾಡುತ್ತದೆ.

ಹುಡುಕಾಟ ಫಲಿತಾಂಶಗಳನ್ನು ಹೈಲೈಟ್ ಮಾಡಲು ಮೂಲ ಪಠ್ಯವನ್ನು ಮರುಲೋಡ್ ಮಾಡುವ ಅಗತ್ಯವಿದೆ ಮತ್ತು `service worker` ಹೊಂದಿಸುವುದು ಪುನರಾವರ್ತಿತ ನೆಟ್ವರ್ಕ್ ವಿನಂತಿಗಳನ್ನು ತಪ್ಪಿಸಬಹುದು.

ಅದೇ ಸಮಯದಲ್ಲಿ, `service worker` ಎಲ್ಲಾ ಲೇಖನಗಳನ್ನು ಸಂಗ್ರಹಿಸುವುದರಿಂದ, ಬಳಕೆದಾರರು ಒಮ್ಮೆ ಹುಡುಕಾಟವನ್ನು ನಿರ್ವಹಿಸಿದರೆ, ಹುಡುಕಾಟ ಸೇರಿದಂತೆ ಸಂಪೂರ್ಣ ವೆಬ್ಸೈಟ್ ಆಫ್ಲೈನ್ನಲ್ಲಿ ಲಭ್ಯವಿದೆ.

## ಮಾರ್ಕ್ಡೌನ್ ಡಾಕ್ಯುಮೆಂಟ್ಗಳ ಪ್ರದರ್ಶನ ಆಪ್ಟಿಮೈಸೇಶನ್

`i18n.site` ರ ಶುದ್ಧ ಫ್ರಂಟ್-ಎಂಡ್ ಹುಡುಕಾಟ ಪರಿಹಾರವನ್ನು `MarkDown` ಡಾಕ್ಯುಮೆಂಟ್ಗಳಿಗೆ ಆಪ್ಟಿಮೈಸ್ ಮಾಡಲಾಗಿದೆ.

ಹುಡುಕಾಟ ಫಲಿತಾಂಶಗಳನ್ನು ಪ್ರದರ್ಶಿಸುವಾಗ, ಅಧ್ಯಾಯದ ಹೆಸರನ್ನು ಪ್ರದರ್ಶಿಸಲಾಗುತ್ತದೆ ಮತ್ತು ಕ್ಲಿಕ್ ಮಾಡಿದಾಗ ಅಧ್ಯಾಯವನ್ನು ನ್ಯಾವಿಗೇಟ್ ಮಾಡಲಾಗುತ್ತದೆ.

![](//p.3ti.site/1727686552.avif)

## ಸಾರಾಂಶಗೊಳಿಸಿ

ತಲೆಕೆಳಗಾದ ಪೂರ್ಣ-ಪಠ್ಯ ಹುಡುಕಾಟವನ್ನು ಸಂಪೂರ್ಣವಾಗಿ ಮುಂಭಾಗದ ತುದಿಯಲ್ಲಿ ಅಳವಡಿಸಲಾಗಿದೆ, ಯಾವುದೇ ಸರ್ವರ್ ಅಗತ್ಯವಿಲ್ಲ. ಡಾಕ್ಯುಮೆಂಟ್ಗಳು ಮತ್ತು ವೈಯಕ್ತಿಕ ಬ್ಲಾಗ್ಗಳಂತಹ ಸಣ್ಣ ಮತ್ತು ಮಧ್ಯಮ ಗಾತ್ರದ ವೆಬ್ಸೈಟ್ಗಳಿಗೆ ಇದು ತುಂಬಾ ಸೂಕ್ತವಾಗಿದೆ.

`i18n.site` ಓಪನ್ ಸೋರ್ಸ್ ಸ್ವಯಂ-ಅಭಿವೃದ್ಧಿಪಡಿಸಿದ ಶುದ್ಧ ಫ್ರಂಟ್-ಎಂಡ್ ಹುಡುಕಾಟ, ಗಾತ್ರದಲ್ಲಿ ಚಿಕ್ಕದಾಗಿದೆ ಮತ್ತು ವೇಗದ ಪ್ರತಿಕ್ರಿಯೆ, ಪ್ರಸ್ತುತ ಶುದ್ಧ ಮುಂಭಾಗದ ಪೂರ್ಣ-ಪಠ್ಯ ಹುಡುಕಾಟದ ನ್ಯೂನತೆಗಳನ್ನು ಪರಿಹರಿಸುತ್ತದೆ ಮತ್ತು ಉತ್ತಮ ಬಳಕೆದಾರ ಅನುಭವವನ್ನು ಒದಗಿಸುತ್ತದೆ.